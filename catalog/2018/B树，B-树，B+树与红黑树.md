### B树，B-树，B+树与红黑树

#### 二叉查找树

> 二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：
> （1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
> （2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；
> （3）左、右子树也分别为二叉排序树；
> （4）没有键值相等的节点（因此，插入的时候一定是叶子节点）。
>
> 插入有序节点，退化成单支树
> ​    1.查找效率最好O(logn)，最坏O(n)
> ​    2.插入效率和查找效率相同（只插入叶子节点）
> ​    3.删除效率最好O(logn)+O(1)->左子树和右子树同时存在
> ​            最差O(n)->只有左子树或者右子树

#### 平衡二叉查找树

> 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。常用算法有红黑树、AVL、Treap、伸展树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O（log2n），大大降低了操作的时间复杂度。

#### 红黑树

> (1) 每个节点或者是黑色，或者是红色。
> (2) 根节点是黑色。
> (3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]
> (4) 如果一个节点是红色的，则它的子节点必须是黑色的。
> (5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

> (1) 查找代价：由于红黑树的性质(**最长路径长度不超过最短路径长度的2倍**)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。**其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点**。 
> (2) 插入代价：RBT插入结点时，**需要旋转操作和变色操作**。但由于只需要保证RBT基本平衡就可以了。**因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样**。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。 
> (3) 删除代价：RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。 
> RBT 效率总结 : 查找 效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些，**但也远远好于BST**。 
> 插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。**因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，删除最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)**。虽然变色操作的时间复杂度在O(logN)，但是实际上，这种操作由于简单所需要的代价很小。

#### 2-3树

> 定义：
>
> - 所有叶子节点在同一层上
> - 可以有2结点和3结点两种结点类型，其中每个结点要么是满孩子要么没有孩子。

##### 插入：

> 若为2结点，则升级为3结点
>
> 若为3结点则拆分，若父节点为2结点，将父节点升级为3结点；若父节点为3结点，则同理；若父节点为根节点则树只能增加高度。

#### 2-3-4树

> 定义：
>
> - 比2-3树多了一个4结点的存在

#### B树

> 1、根结点至少有两个子女； 
> 2、每一个非根的分支结点都有k-1个元素和k个孩子，其中 $$\lceil m/2 \rceil <= k <= m $$。每一个叶子结点n都有k-1个元素，其中$$ \lceil m/2 \rceil <= k <= m $$
>
> 3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：m/2<= k <= m ； 
> 4、所有的叶子结点都位于同一层。 
>
> m（阶数：单个结点最大拥有孩子数）

**为何用B树**

> 

