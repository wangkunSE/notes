## 并发编程实战

### 一 简介

#### 1.1 并发简史

> 一次占用全部的计算资源严重浪费现有资源。因此操作系统提供了进程，进程是最基本的资源配置单元。线程是轻量级的进程，线程是最基本的资源调度单元。

#### 1.2 线程的优势

> 线程可以降低程序的开发（？）和维护成本，同时提升复杂应用程序的性能。

##### 1.2.1 发挥多核处理器的强大能力

> 合理使用线程在多核处理器的机器上能够提高系统吞吐率。

##### 1.2.2 建模的简单性

> 将多种任务通过线程区分成单独的任务。从而使线程内的代码只用关注自己的逻辑。

##### 1.2.3 异步事件的简化处理

> 例如Socket开发。

##### 1.2.4 响应更灵敏的用户界面

#### 1.3 线程带来的风险

##### 1.3.1 安全性问题

```java
@NotThreadSafe
public class UnsafeSequence{
  private int value;
  
  public int getNext(){
    return value++;
  }
}
```

![1.1](./images/concurrent/1.1.jpg)

> 若要使上面的方法安全执行，则需要同步代码，通过同步代码块或者同步方法。

##### 1.3.2 活跃性问题

**安全性定义**：永远不发生糟糕的事情。

**活跃性定义** ：某件正确的事情最终会发生。（线程中死锁）

##### 1.3.3 性能问题

> 上下文切换（临时挂起一个活跃线程转而运行另一个线程。保存和恢复执行上下文，丢失局部性。同步机制会抑制编译器优化，增加内存总线的同步流量）

#### 1.4 线程无处不在

> Servlet(ServletContext，HttpSession)。Swing、AWT。RMI

### 二 线程安全性

> 一个对象是否需要是线程安全的，取决于它是否被多个线程访问。这指的是访问对象的方式，而不是对象要实现的功能。

**Java中的主要同步机制**:

> synchronized（独占的加锁方式），volatile，显式锁（Explicit Lock）以及原子变量。

> 线程安全性是一个在代码上使用的术语，但它只是与状态相关，因此只能应用于**封装其状态**的整个代码，这可能是一个对象，也可能是整个程序。

#### 2.1 什么是线程安全性

**正确性** ：某个类的行为与其规范完全一致。

**线程安全性** ：当多个线程访问某个类时，这个类始终都能表现出正确的行为，则这个类就是线程安全的。

**无状态对象一定是线程安全的。**

#### 2.2 原子性

**竞态条件（Race Condition）：**由于不恰当的执行时序而出现不正确的结果。

##### 2.2.1 竞态条件

> 得到正确结果必须取决于事件的发生时序。

**先检查后执行：**首先观察到某个条件为真，然后根据观察结果采用相应的动作。

##### 2.2.2 延迟初始化中的竞态条件

```java
@NotThreadSafe
public class LazyInitRace{
  private ExpensiveObject instance = null;
  
  public ExpensiveObject getInstance(){
    if( null == instance){
      instance = new ExpensiveObject();
    }
    return instance;
  }
}
```

##### 2.2.3 复合操作

> 原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说。这个操作是一个以原子方式执行的操作。

**复合操作：**包含了一组必须以原子方式执行的操作以确保线程安全性。

> 在实际并发编程中，应尽可能地使用现有的线程安全对象来管理类的状态。

#### 2.3 加锁机制

> **要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。**

##### 2.3.1 内置锁

> 以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。Java的内置锁相当于一种**互斥体（或互斥锁）**。即线程A尝试获取一个由线程B持有的锁时，线程A必须等待或者阻塞，直到线程B释放这个锁。

##### 2.3.2 重入

> 内置锁是可重入的。这意味着获取锁的操作粒度是“线程”，而不是“调用”。

```java
public class Widget{
  public synchronized void doSomething(){
    //...
  }
}
public class LoggingWidget extends Widget{
  public synchronized void doSomething(){
    System.out.println(toString()+" :calling doSomething.");
    super.doSomething(); //若内置锁不可重入，则该方法会产生死锁。    
  }
}
```

#### 2.4 用锁来保护状态

> 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

> 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。

> 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。

#### 2.5 活跃性与性能

![Poor Concurrency](./images/concurrent/2.1.jpg)

> 通常，在简单性和性能之间存在着相互制约因素。

> **当执行时间较长的计算或者可能无法快速完成的操作时（网络I/O、控制台I/O），一定不要持有锁**